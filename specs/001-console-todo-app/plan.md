# Implementation Plan: In-Memory Console Todo Application

**Branch**: `001-console-todo-app` | **Date**: 2026-01-02 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-console-todo-app/spec.md`

**Note**: This document is generated by the `/sp.plan` command following the Spec-Driven Development workflow.

## Summary

Build a Python command-line todo application that stores tasks entirely in memory with zero persistence. The app provides CRUD operations (Create, Read, Update, Delete) for managing todos, status tracking (complete/incomplete), optional categorization and priority levels, comprehensive input validation, and a clean menu-driven CLI interface. Architecture follows strict modular separation (Models/Services/CLI/Lib) to facilitate future migration to web/API interfaces in Phase II while maintaining Phase I simplicity with no external dependencies beyond Python stdlib and pytest.

## Technical Context

**Language/Version**: Python 3.13+ (as specified in requirements; backward compatible to 3.8 per constitution)
**Primary Dependencies**: Python Standard Library only (no external packages for core functionality)
**Storage**: In-memory only (list-based data structure, no persistence)
**Testing**: pytest (only external dependency)
**Target Platform**: Cross-platform console (Windows, macOS, Linux - anywhere Python runs)
**Project Type**: Single project (console CLI application)
**Performance Goals**:
- Add todo confirmation < 5 seconds
- View list display < 2 seconds
- Handle 1000+ todos without degradation
- All operations instant response on modern hardware

**Constraints**:
- Zero external dependencies (Python stdlib only, pytest for testing)
- In-memory storage only (no files, no database)
- No persistence (data lost on exit)
- Single-user, single-session
- 80-character terminal width minimum
- Menu-driven interaction (no command-line arguments for operations)

**Scale/Scope**:
- Single-user console application
- Expected usage: 10-100 todos per session
- Support up to 1000+ todos for performance validation
- ~300-500 lines of production code estimate
- ~500-800 lines of test code estimate

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Phase-Aware Architecture ✅ PASS
- ✅ Phase I: In-memory Python console app with zero external dependencies (requirement met)
- ✅ Clean module boundaries (Models/Services/CLI/Lib) enable future web/API migration
- ✅ No premature complexity for future phases
- ✅ Entity model (Todo) can evolve to ORM models in Phase II without API changes

**Justification**: Architecture uses standard Python patterns (dataclasses for models, plain functions for services) that translate directly to web frameworks (FastAPI models, service layer). CLI interface isolates all user interaction, making it replaceable with REST endpoints.

### Principle II: Test-First Development (NON-NEGOTIABLE) ✅ PASS
- ✅ TDD workflow enforced: Write tests → User approval → Red → Green → Refactor
- ✅ All 16 functional requirements have corresponding test scenarios
- ✅ 4 user stories with acceptance criteria map to integration tests
- ✅ Contract tests for data model, unit tests for services, integration tests for user flows

**Justification**: Plan includes explicit testing strategy with test file organization. Implementation will follow strict Red-Green-Refactor for all code.

### Principle III: Independent User Stories ✅ PASS
- ✅ P1 (Add/View): Independently deliverable MVP - core value without dependencies
- ✅ P2 (Complete/Incomplete): Builds on P1 data model, adds status management
- ✅ P3 (Update/Delete): Completes CRUD without changing P1/P2 functionality
- ✅ P4 (Categories/Priorities): Optional enhancement, no impact on P1-P3

**Justification**: Each priority level delivers incremental value. P1 alone is a usable todo tracker. P2-P4 are additive enhancements with no cross-dependencies.

### Principle IV: Modular Implementation ✅ PASS
- ✅ **Models** (`src/models/`): Todo dataclass with validation
- ✅ **Services** (`src/services/`): TodoManager with business logic
- ✅ **CLI** (`src/cli/`): Menu handler and user interaction
- ✅ **Lib** (`src/lib/`): Input validation, display formatting utilities

**Justification**: Clear separation of concerns. Models hold data, Services contain logic, CLI handles I/O, Lib provides reusable utilities. Each module independently testable.

### Principle V: Input Validation & Error Handling ✅ PASS
- ✅ Validation at CLI boundary (all user input validated before service calls)
- ✅ 8 edge cases identified with explicit error messages
- ✅ All operations return Result types (success/error) for consistent error handling
- ✅ User-friendly messages for all failure scenarios

**Justification**: Spec requires clear error messages (FR-010, FR-016). Architecture uses validation layer in CLI module and defensive programming in services.

### Principle VI: Simplicity & YAGNI ✅ PASS
- ✅ NO database persistence (in-memory list only)
- ✅ NO web frameworks (plain Python CLI)
- ✅ NO external dependencies (Python stdlib + pytest only)
- ✅ NO authentication (single-user console app)
- ✅ NO premature abstractions (no interfaces, no dependency injection, no factories)

**Justification**: Minimal viable implementation. Todo stored as Python list. Services are plain functions/classes. No over-engineering.

### Principle VII: Comprehensive Documentation ✅ PASS
- ✅ Spec.md: Complete with user stories, requirements, success criteria
- ✅ Plan.md: This document with architecture and decisions
- ✅ Tasks.md: Will be generated by `/sp.tasks` command
- ✅ README.md: Will include quick-start, usage examples, development setup
- ✅ PHRs: Tracking all agent interactions
- ✅ ADRs: Will document architectural decisions (if significant choices arise)

**Justification**: Full documentation workflow followed. Code will include docstrings for all public functions/classes.

### Overall Gate Status: ✅ ALL CHECKS PASS

**No violations requiring justification.** Proceed with Phase 0 research.

## Project Structure

### Documentation (this feature)

```text
specs/001-console-todo-app/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (in progress)
├── research.md          # Phase 0 output (pending)
├── data-model.md        # Phase 1 output (pending)
├── quickstart.md        # Phase 1 output (pending)
├── contracts/           # Phase 1 output (pending)
│   └── cli-interface.md # CLI menu contract
├── checklists/
│   └── requirements.md  # Spec quality checklist (completed)
└── tasks.md             # Phase 2 output (/sp.tasks command)
```

### Source Code (repository root)

```text
src/
├── __init__.py
├── __main__.py          # Entry point (python -m src)
├── models/
│   ├── __init__.py
│   └── todo.py          # Todo dataclass with validation
├── services/
│   ├── __init__.py
│   └── todo_manager.py  # TodoManager class (in-memory CRUD)
├── cli/
│   ├── __init__.py
│   ├── menu.py          # Menu display and navigation
│   └── handlers.py      # User input handlers
└── lib/
    ├── __init__.py
    ├── validators.py    # Input validation utilities
    └── formatters.py    # Display formatting utilities

tests/
├── __init__.py
├── contract/
│   ├── __init__.py
│   └── test_todo_model.py  # Todo dataclass contract tests
├── integration/
│   ├── __init__.py
│   ├── test_p1_add_view.py  # P1 user story tests
│   ├── test_p2_complete.py  # P2 user story tests
│   ├── test_p3_update_delete.py  # P3 user story tests
│   └── test_p4_categorize.py    # P4 user story tests
└── unit/
    ├── __init__.py
    ├── test_todo_manager.py  # TodoManager unit tests
    ├── test_validators.py    # Validation utility tests
    └── test_formatters.py    # Formatting utility tests

pyproject.toml           # UV project configuration
README.md                # Quick-start guide
.gitignore               # Python ignore patterns
```

**Structure Decision**: Selected **Option 1: Single project** structure because this is a standalone console application with no frontend/backend separation needed. All code lives under `src/` with clean module organization. Tests organized by type (contract/integration/unit) and aligned with user stories for traceability.

## Complexity Tracking

> No constitution violations detected. This section intentionally left empty.

---

## Phase 0: Research (COMPLETED ✅)

**Artifacts**: [research.md](./research.md)

**Research Areas Completed**:
1. Python Version and Compatibility → Python 3.13+ (compatible to 3.8)
2. Project Structure and Module Organization → Models/Services/CLI/Lib separation
3. Data Storage Pattern → In-memory list with TodoManager service class
4. Data Model Design → `@dataclass` for Todo with validation
5. CLI Interface Pattern → Menu-driven with numbered options
6. Input Validation Strategy → CLI boundary validation with dedicated validators
7. Error Handling Pattern → `Optional` and tuple returns (no exception-based flow)
8. Testing Strategy → Three-tier: contract, unit, integration with pytest
9. Development Workflow Tools → UV, pytest, optional mypy
10. User Experience Design → Friendly menu with visual feedback

**Key Decisions**:
- Use dataclasses for clean model definition
- TodoManager encapsulates list storage
- Menu-driven interface (not CLI args)
- Validation at CLI boundary
- Return-based error handling (not exceptions)
- TDD with pytest (three test levels)
- UV for package management
- Simple UX with symbols (✓ ✗ [ ] [X])

**All unknowns resolved. Proceeding to Phase 1.**

---

## Phase 1: Design & Contracts (COMPLETED ✅)

### Artifacts Generated

1. **[data-model.md](./data-model.md)** - Complete data model specification
   - Todo entity with 6 attributes (id, title, completed, category, priority, created_at)
   - Validation rules and invariants
   - TodoManager operations contract (10 methods)
   - Performance characteristics (time/space complexity)
   - Phase II migration path to SQLModel

2. **[contracts/cli-interface.md](./contracts/cli-interface.md)** - CLI interface contract
   - Complete menu structure and navigation flow
   - All 7 operations with input/output specifications
   - Error handling for all edge cases
   - Visual standards (symbols, formatting, prompts)
   - Success criteria validation (SC-001 through SC-010)

3. **[quickstart.md](./quickstart.md)** - User and developer guide
   - Installation instructions (Python + UV setup)
   - First-time user experience walkthrough
   - Common workflows (daily tasks, filtering, updates, cleanup)
   - Menu reference and tips
   - Troubleshooting guide
   - Example complete session

### Design Decisions Summary

**Data Model**:
- Todo as `@dataclass` with `__post_init__` validation
- 6 attributes: id (int), title (str), completed (bool), category (Optional[str]), priority (str), created_at (datetime)
- TodoManager with 10 CRUD operations
- Sequential ID assignment (1, 2, 3, ...)
- In-memory list storage (O(n) operations acceptable for <1000 todos)

**CLI Interface**:
- Main menu with 7 numbered options
- Status line showing total/completed/pending counts
- Visual feedback: ✓ (success), ✗ (error), [ ] (incomplete), [X] (complete)
- Input validation at every prompt with clear error messages
- Confirmation required for destructive operations (delete)
- Graceful handling of Ctrl+C (same as Exit)

**Module Structure** (final):
```
src/
├── models/todo.py           # Todo dataclass
├── services/todo_manager.py # TodoManager service
├── cli/menu.py              # Menu display
├── cli/handlers.py          # Input handlers
├── lib/validators.py        # Validation utilities
└── lib/formatters.py        # Display formatting

tests/
├── contract/test_todo_model.py
├── integration/test_p1_add_view.py (and P2, P3, P4)
└── unit/test_todo_manager.py (and validators, formatters)
```

---

## Constitution Check - Post-Design ✅ RE-VALIDATED

All principles re-validated after Phase 1 design:

- ✅ **Phase-Aware Architecture**: Clean module boundaries enable Phase II migration
- ✅ **Test-First Development**: Test structure defined (contract/unit/integration)
- ✅ **Independent User Stories**: Design supports P1-P4 independent implementation
- ✅ **Modular Implementation**: Models/Services/CLI/Lib separation confirmed
- ✅ **Input Validation & Error Handling**: Comprehensive validation layer specified
- ✅ **Simplicity & YAGNI**: No over-engineering, minimal dependencies
- ✅ **Comprehensive Documentation**: All artifacts complete

**No violations. Design approved for implementation.**

---

## Implementation Readiness

### Ready for `/sp.tasks` Command

**Prerequisites Met**:
- [x] Spec.md complete with user stories and requirements
- [x] Plan.md complete with technical context and constitution check
- [x] Research.md with all technology decisions documented
- [x] Data-model.md with entity definitions and contracts
- [x] Contracts/cli-interface.md with complete UI specification
- [x] Quickstart.md with usage guide

**Next Steps**:
1. Run `/sp.tasks` to generate dependency-ordered implementation tasks
2. Tasks will be organized by user story (P1-P4) following spec priorities
3. TDD workflow: Write tests → Get approval → Red → Green → Refactor
4. Each task will reference specific sections of design artifacts

---

## Architectural Decision Summary

### ADR-Worthy Decisions (Optional)

While no formal ADRs are required for Phase I (per YAGNI principle), these decisions were significant and documented in research.md:

1. **Data Storage**: In-memory list vs. dict vs. SQLite in-memory
   - **Decision**: List-based storage in TodoManager
   - **Rationale**: Simplest solution, meets performance requirements, clean migration path

2. **Data Model Pattern**: Dataclass vs. namedtuple vs. plain class vs. TypedDict
   - **Decision**: `@dataclass` with validation
   - **Rationale**: Pythonic, minimal boilerplate, extensible to Pydantic/SQLModel

3. **CLI Pattern**: Menu-driven vs. CLI args vs. REPL
   - **Decision**: Menu-driven numbered options
   - **Rationale**: User-friendly, self-documenting, meets spec requirement SC-007

4. **Error Handling**: Exception-based vs. return-based vs. Result monad
   - **Decision**: `Optional` and tuple returns
   - **Rationale**: Simple, testable, Pythonic, no over-engineering

No ADR creation needed (documented in research.md is sufficient for Phase I).

---

## Risk Assessment

### Technical Risks: LOW ✅

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Performance degradation with 1000+ todos | Low | Low | O(n) operations acceptable, spec validated |
| Cross-platform CLI rendering issues | Low | Medium | Use ASCII only, no terminal colors/control codes |
| Python version compatibility issues | Very Low | Medium | Target 3.8+ with tested backward compatibility |
| User confusion with menu interface | Low | Medium | Quickstart guide, clear prompts, self-explanatory UI |

**Overall Risk**: Minimal. Standard Python patterns, no complex dependencies, well-defined requirements.

---

## Plan Status: ✅ COMPLETE

**Completion Summary**:
- Technical Context: ✅ Filled
- Constitution Check: ✅ Passed (validated twice)
- Phase 0 Research: ✅ Complete (research.md)
- Phase 1 Design: ✅ Complete (data-model.md, contracts/, quickstart.md)
- All unknowns: ✅ Resolved
- All design artifacts: ✅ Generated

**Ready for Phase 2**: `/sp.tasks` command to generate implementation task list.

---

**Planning Complete**: 2026-01-02
**Architect**: Claude Sonnet 4.5 (via Spec-Driven Development workflow)
**Next Command**: `/sp.tasks` to generate dependency-ordered implementation tasks
